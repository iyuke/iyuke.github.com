---
layout: post
title: 垃圾回收器
date: 2017-08-15 13:32:20 +0300
description: You’ll find this post in your `_posts` directory. Go ahead and edit it and re-build the site to see your changes. # Add post description (optional)
img: how-to-start.jpg # Add image post (optional)
tags: [academic]
---
Don't be jealous of others. Because you never know how much you will get in the next second. 

#### java没有明确说明jvm使用哪一种垃圾回收机制，但基本要做两件事  

1，发现无用的信息对象  

2.回收无用信息对象的内存空间

#### java里的内存泄露指的是一个内存对象的生命周期超过了程序需要他的时间长度

垃圾回收算法大概有以下几种:

1.引用计数法。堆中的每一个对象都有引用计数器，当它被引用一次时，则该引用计数器加1，但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1，当计数器为0时，可以被垃圾回收器回收。但缺点是出现循环引用的时候，对象不能被回收。

2.清除-整理算法。通过根搜索算法，从一个根节点开始寻找，找对应的引用节点，找到后，再找这个节点的引用节点，所有引用节点找寻完毕以后，剩余的节点则被认为没有引用的节点，需要被回收。回收好以后，可能会造成内存碎片，对对象进行移动整理。

3.复制算法。解决堆碎片垃圾回收，它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集中扫描活动对象，并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。

4.generation算法

### Young:

1.Serial：使用一个CPU或一条收集线程去完成垃圾收集工作，它在进行垃圾收集时，必须暂停其他的所有线程，直到它收集结束。

2.ParNew：Serial的多线程版本，但是只有它能与CMS收集器配合。

3.Parallel Scavenge：CMS等的收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目的是达到一个可控制的吞吐量，就比如虚拟机总共运行了100分钟，其中垃圾收集花掉了一分钟，那吞吐量就是99%。Parallel Scavenge 提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio。

### Old:
Serial Old：单线程收集器，使用标记-整理算法，可与Parallel Scavenge搭配

Parallel Old：使用多线程和标记-整理算法

CMS：以获取最短停顿时间为目标的收集器，经过四个步骤，初始标记，并发标记，重新标记，并发清除。初始标记和重新标记这两个步骤仍然需要stop the world，初始标记仅仅标记一下GC Roots，速度很快，并发标记就是进行GC Roots Tracing的过程，而重新标记是为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，最后是并发清除。缺点：1.CMS收集器对CPU资源非常敏感，并发阶段，虽然不会导致用户线程停顿，但是会以为占用一部分CPU资源而导致应用程序变慢，吞吐量降低。2.CMS无法处理浮动垃圾，因为并发清理阶段用户线程还在运行，伴随程序运行还有新的垃圾不断产生，这一部分垃圾出现在标记过程后，CMS无法在当次收集中处理它们，等下一次GC再清理。3.CMS是基于标记-清除的会导致空间碎片过多而触发一次full GC，CMS也有一个参数用于在CMS收集器顶不住要进行full GC的时候开启内存碎片的合并整理过程，内存整理是无法并发的，空间碎片问题没有了，但停顿时间变长了。

G1收集器：G1S收集器独立管理整个GC堆，它将整个java堆划分成多个大小相同的独立区域，它也经过了4个步骤，初始标记，并发标记，最终标记，帅选回收，步骤和CMS大致相同，在最后帅选回收时，首先会对各个区域的回收价值进行排序，根据用户所期望的GC停顿时间来制定回收计划。G1有以下几个特点1.可以利用多CPU的优势来缩短stop the world的时间 。2.G1独立管理整个GC堆，采用不同的方式去处理新创建的对象和已经存活了一段时间的对象等。3.G1运行期间不会产生内存碎片，收集后能提供规整的可用内存。4.建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。之所以能建立可预测的停顿模型，是因为它可以有计划的避免在整个java堆中进行全区域的垃圾收集，G1跟踪各个区域的垃圾堆积的价值大小，在后台维护一个优先列表，优先回收最大的区域。

### 触发full GC

1.年老代（Tenured）被写满

2.持久代（Perm）被写满

3.System.gc()被显示调用

4.统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间

很多的对象一开始是分配在年轻代的，这些对象在熬过了一定次数的young gc之后，就进入了年老代。同时，一些比较大的对象，
一开始就可能被直接分配到年老代中（因为年轻代比较小）。
大部分的对象被直接分配到年轻代的eden区（之前已经提到了是，很大的对象会被直接分配到年老代中），
survivor区里面放至少熬过一个YGC的对象，在survivor里面的对象，才有机会被考虑提升到年老代中。
同一时刻，两个survivor只被使用一个，另外一个是用来进行复制GC时使用的。

### 为什么新生代用复制算法，而老年代用标记清除或者标记整理算法
在新生代中，每次垃圾收集时，都有大批的对象死去，只有少量存活，所以选用复制算法，只需要少量存活对象的复制成本就可以完成收集。而老年代因为对象存活率高，没有额外的空间对它进行分配担保，就必须使用标记清除或者标记整理算法